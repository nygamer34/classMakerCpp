#This is as is
#Concept is to create input file with name of class, functions and variable names and create a .cpp and .header file
#Requires ruby (tested on ruby 2.3.3p222) 
#Command line format:
#ruby dcg_class_maker.rb <filename> <verbose> 
#
#example 
#ruby dcg_class_maker.rb createController 
#
##Example of input file
##Create a text file with the following: (Note the '#' symbols are comments so in the actual file remove #)
##<c = class declaration> <name of class>
##<v = variable declartion> <variableType> <variableName>
##<f = function declartion> <returnType> <functionName>
# Actual file is below (remove #s)
#c DCGScripts
#v Vector3<DCGScriptBlueprint*> mBlueprints
#v int mIntValue
#v bool mBoolValue
#v float mFloatValue
#f void initScripts
require 'fileutils'
def getTextInstructions
	return "#
#How to Use:
#Create a input file with name of class, functions and variable names. Pass in file through command line and this will create a .cpp and .header file
#Requires ruby (tested on ruby 2.3.3p222) 
#Commandline structure:
#ruby dcg_class_maker.rb <filename> <verbose> 
#
#example: 
#ruby dcg_class_maker.rb DCGController 
#
##Example of input file:
##How to create the input file: (Note the '#' symbols are comments so in the actual file remove #)
##<c = class declaration> <name of class>
##<v = variable declartion> <variableType> <variableName>
##<f = function declartion> <returnType> <functionName>
#Actual file is below (remove #s), file will skip lines that start with #
#c DCGScripts
#v Vector3<DCGScriptBlueprint*> mBlueprints
#v int mIntValue
#v bool mBoolValue
#v float mFloatValue
#f void initScripts"
end

def headerIncludeFiles()
	headerIncludeFile("../include/DCGConstants.h")

end
def headerIncludeFile(completeFilePathAndName)
	$header_out_file.puts("#include \"#{completeFilePathAndName}\"")
end
def srcIncludeFile(completeFilePathAndName)
	$src_out_file.puts("#include \"../include/#{completeFilePathAndName}\"")
end

def cppAddFunction(returnType, functionName, params="")
	if returnType.empty?
		$src_out_file.puts("#{$className}::#{functionName}(#{params})")
	else
		$src_out_file.puts("#{returnType} #{$className}::#{functionName}(#{params})")
	end
	$src_out_file.puts("{\n\n}")
end


def cppAddFunctions()
	cppAddFunction("", "#{$className}")
	cppAddFunction("", "~#{$className}")

	$functionsToCreate.each do|args|
		allParams = getParamsString(args)
		if $verbose == true
			puts "allParams #{allParams}"
		end
		cppAddFunction(args[0], args[1], allParams)

	end
end
def headerAddFunction(returnType, functionName, params="")
	
	if returnType.empty?
		$header_out_file.puts("#{$indent}#{functionName}(#{params});")
	else
		$header_out_file.puts("#{$indent}#{returnType} #{functionName}(#{params});")
	end
end
def headerAddVariable(returnType, variableName)
	$header_out_file.puts("#{$indent}#{returnType} #{variableName};")
end
def getParamsString(args)
	params = ""
	allParams = ""
	args.drop(2).each do |param|
		params += param
		params += " "
	end
	if params.nil? || params.empty?
		return ""
	end
	if $verbose == true
		puts "params to parse #{params}"
	end
	count = 1
	paramsString = ""
	params.split(" ").each do |param|
		paramCount = 0
		param.split(":").each do |singleParam|
			paramsString += singleParam
			if paramCount < 1
				paramsString += " "
			end
			paramCount += 1
		end
		if count < params.split(" ").length
			paramsString += ", "
		end
		count += 1
	end
	return paramsString
end
def headerAddFunctions()
	headerAddFunction("", "#{$className}")
	headerAddFunction("", "~#{$className}")

	$functionsToCreate.each do|args|
		if $verbose == true
			puts"addFunction Args #{args} "
		end
		if args.length == 2
			headerAddFunction(args[0], args[1])
		else
			allParams = getParamsString(args)
			if $verbose == true
				puts "allParams #{allParams}"
			end
			headerAddFunction(args[0], args[1], allParams)
		end
	end
end
def headerAddVariables()

	$variablesToCreate.each do|args|
		headerAddVariable(args[0], args[1])
	end
end
def createCPlusPlusHeader()
		#...
	date = Time.now.strftime("%Y/%m/%d/ %H:%M")
	$header_out_file.puts("//Generated by #{$nameGenerator} on #{date}")
	$header_out_file.puts("#pragma once")
	headerIncludeFiles()
		#...
	$header_out_file.puts("class #{$className}")
	$header_out_file.puts("{")
	$header_out_file.puts("public:")
   	headerAddVariables();

	headerAddFunctions();
	
	$header_out_file.puts("};")

	$header_out_file.close
end
def createCPlusPlusSrc()
	date = Time.now.strftime("%Y/%m/%d/ %H:%M")

	$src_out_file.puts("//Generated by #{$nameGenerator} on #{date}\n\n")

	srcIncludeFile("#{$className}.h")
	cppAddFunctions()

	$src_out_file.close
end
def getFormattedLine(lineToFix)
	return lineToFix.chomp() #gsub('\n', '')
end
def createClassByFile(fileName)
	$functionsToCreate.clear
	$variablesToCreate.clear
	puts "Parsing: #{fileName}"
  	f = File.open(fileName, "r")
	f.each_line { |line|
		if $verbose
			puts "Parsing #{line}"
		end
  		lineSplit = line.split(' ', 2)
  		if lineSplit[0] == 'c'
  			if lineSplit.length < 2
  				puts "format should be c <className>"
  				return
  			end
  			$className = getFormattedLine(lineSplit[1])
  			puts "creating class #{$className}"

  		elsif lineSplit[0] == 'f'
  			  if lineSplit.length < 2
  			  	puts "format should be f <returnType> <functionName> <returnType:paramName> <. . .as many params as needed>"
  			  	return
  			  end
  			  functionValue = getFormattedLine(lineSplit[1])
  			  puts "add function #{functionValue}"
			  $functionsToCreate.push(functionValue.split(" "))
  		elsif lineSplit[0] == 'v'
  			if lineSplit.length < 2
  			  	puts "format should be v <variableType> <variableName>"
  			  	return
  			  end
  			 variableValue = getFormattedLine(lineSplit[1])
  			  puts "add variable #{variableValue}"
			  $variablesToCreate.push(variableValue.split(" "))
  		elsif line[0] == '#' || lineSplit[0] == '#'
  			if $verbose
  				puts "line skipped comment"
  			end
  		end
	}
  	f.close

	if $verbose == true
	  puts "#{$className} functionsToCreate: #{$functionsToCreate}"
	  puts "#{$className} variablesToCreate: #{$variablesToCreate}"
	end

	$header_out_file = File.new("#{$headerPath}/#{$className}.h", "w")
	$src_out_file = File.new("#{$srcPath}/#{$className}.cpp", "w")

	createCPlusPlusHeader()
	createCPlusPlusSrc()
end
$indent = "    "
$nameGenerator = "DCG Generator"
$className ="";
$count = 1;
$headerPath = __dir__ + "/headers" 
$srcPath = __dir__ + "/src" 
unless File.directory?($headerPath)
  FileUtils.mkdir_p($headerPath)
end
unless File.directory?($srcPath)
  FileUtils.mkdir_p($srcPath)
end
$functionsToCreate = Array.new()
$variablesToCreate = Array.new()
if ARGV.length < 1
	puts getTextInstructions
	return
end


$verbose = false
if ARGV.length == 0 || ARGV[0] == "help" || ARGV[0] == "h" || ARGV[0] == "-help" || ARGV[0] == "-h"
		puts getTextInstructions
		return
elsif(ARGV.length > 1)
	if ARGV[1] == "help" || ARGV[1] == "h" || ARGV[1] == "-help" || ARGV[1] == "-h"
		puts getTextInstructions
		return
	end
	if ARGV[1] == "true"
		$verbose = true
		puts "Verbose: is on"
	end
end
arg1 = ARGV[0]
if File.file?(arg1)
    createClassByFile(arg1)
elsif File.directory?(arg1)
	puts "Looping throu: #{arg1}"
	Dir.foreach(arg1) do |item|
  		next if item == '.' or item == '..'
  		# do work on real items
  		puts"#{arg1}/#{item}"
  		createClassByFile("#{arg1}/#{item}")
	end
end
